
/* Class = "NSButtonCell"; title = "AppleImageConversion"; ObjectID = "0AM-nb-Yrd"; */
"0AM-nb-Yrd.title" = "AppleImageConversion";

/* Class = "NSTextFieldCell"; title = "PointerSpeedMul"; ObjectID = "0MH-zm-tw2"; */
"0MH-zm-tw2.title" = "PointerSpeedMul";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces Apple audio protocols with builtin versions.\n\nApple audio protocols allow OpenCore and the macOS bootloader to play sounds and signals for screen reading or audible error reporting. Supported protocols are beep generation and VoiceOver. The VoiceOver protocol is specific to Gibraltar machines (T2) and is not supported before macOS High Sierra (10.13). Older macOS versions use the AppleHDA protocol (which is not currently implemented) instead.\n\nOnly one set of audio protocols can be available at a time, so this setting should be enabled in order to enable audio playback in the OpenCore user interface on Mac systems implementing some of these protocols.\n\nNote: The backend audio driver needs to be configured in UEFI Audio section for these protocols to be able to stream audio."; ObjectID = "0RZ-LX-aI2"; */
"0RZ-LX-aI2.ibShadowedToolTip" = "重新安裝具有內建版本的Apple音訊協議。\nApple音訊協議允許macOS引導程式和OpenCore播放聲音和訊號以進行螢幕閱讀或聲音錯誤報告。\n支援的協議是蜂鳴聲建立和VoiceOver。 在macOS High Sierra（10.13）之前不受支援。相反，較早的macOS版本使用AppleHDA協議，該協議目前尚未實現。\n\n要在實現某些協議的Mac系統上的OpenCore使用者界面中取得音訊播放，應該啟用此設定。\n\n注意：需要在UEFI-->Audio部分中配置後端音訊驅動程式，這些協議才能使用。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: NO\nDescription: Some types of firmware (such as APTIO IV) may contain invalid values in the MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failures on Intel platforms.\n\nNote: While the option is not expected to harm unaffected firmware, its use is recommended only when specifically required."; ObjectID = "0Sc-nS-2YL"; */
"0Sc-nS-2YL.ibShadowedToolTip" = "某些類型的韌體（例如APTIO IV）可能在MSR_FLEX_RATIO（0x194）MSR寄存器中包含無效值. 這些值可能會導致Intel平台上的macOS引導失敗.\n\n注意：雖然該選件預計不會損害不受影響的韌體, 僅在特别需要時才建議使用它.\n如果你沒有在bios中解鎖CFG，一定要選YES";

/* Class = "NSTextFieldCell"; title = "AudioDevice"; ObjectID = "0gM-HU-fz5"; */
"0gM-HU-fz5.title" = "AudioDevice";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Attempts to perform TSC synchronisation with a specified timeout.\n\nThe primary purpose of this quirk is to enable early bootstrap TSC synchronisation on some server and laptop models when running a debug XNU kernel. For the debug kernel the TSC needs to be kept in sync across the cores before any kext could kick in rendering all other solutions problematic. The timeout is specified in microseconds and depends on the amount of cores present on the platform, the recommended starting value is 500000.\n\nThis is an experimental quirk, which should only be used for the aforementioned problem. In all other cases the quirk may render the operating system unstable and is not recommended. The recommended solution in the other cases is to install a kernel driver such as VoodooTSCSync, TSCAdjustReset, or CpuTscSync (a more specialised variant of VoodooTSCSync for newer laptops).\n\nNote: This quirk cannot replace the kernel driver because it cannot operate in ACPI S3 (sleep wake) mode and because the UEFI firmware only provides very limited multicore support which prevents precise updates of the MSR registers."; ObjectID = "0un-PF-SFE"; */
"0un-PF-SFE.ibShadowedToolTip" = "嘗試執行具有指定逾時的TSC同步。\n該怪癖的主要目的是在執行 Debug XNU Kernel 時在某些服務器和可攜式電腦模型上啟用早期引導TSC同步。 對於 Debug Kernel，在任何kext可能導致所有其他解決方案出現問題之前，TSC必須在 Kernel 之間保持同步。逾時以微秒為單位指定，並取決於平台上存在的 Kernel 數量，建議的起始值為500000。\n這是一個實驗性的功能，只能用於上述問題。 在所有其他情況下，可能會使操作系統不稳定，因此不建議這樣做。在其他情況下，推薦的解決方案是安裝 Kernel 驅動程式，如VoodooTSCSync，TSAdjustReset或CpuTscSync。\n\n注意：該問題無法替換 Kernel 驅動程式的原因是，它無法在ACPI S3模式（睡眠喚醒）下執行，並且因為UEFI韌體提供了非常有限的多核支援，從而阻止了MSR寄存器的精確更新。";

/* Class = "NSButtonCell"; title = "EnableJumpstart"; ObjectID = "133-jD-qYy"; */
"133-jD-qYy.title" = "EnableJumpstart";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reconnect console controllers after changing screen resolution.\n\nOn certain firmware, the controllers that produce the console protocols (simple text out) must be reconnected when the screen resolution is changed via GOP. Otherwise, they will not produce text based on the new resolution.\n\nNote: On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required."; ObjectID = "1QT-lu-i79"; */
"1QT-lu-i79.ibShadowedToolTip" = "有些韌體在 GOP 解析度改變後要求重新連接控制器才能輸出文字, 開啟這個選項會導致從 UEFI Shell 中啟動 OpenCore 時直接黑畫面, 盡量避免開啟。\n如果你遇到開機直到登入界面之前一直是黑畫面，請試試選擇 YES。";

/* Class = "NSButtonCell"; title = "ForceResolution"; ObjectID = "2kV-J6-o4B"; */
"2kV-J6-o4B.title" = "ForceResolution";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activate audio support by connecting to a backend driver.\n\nEnabling this setting routes audio playback from builtin protocols to a dedicated audio port (AudioOut) of the specified codec (AudioCodec) located on the audio controller (AudioDevice)."; ObjectID = "2zI-kW-5dk"; */
"2zI-kW-5dk.ibShadowedToolTip" = "通過連接到後端驅動程式來啟用音訊支援(需要增加AudioDxe.efi驅動程式)。\n\n啟用此設定會將音訊播放從內建協議路由到位於音訊控制器（AudioDevice）上的指定編解碼器（AudioCodec）的專用音訊端口（AudioOut）。";

/* Class = "NSButtonCell"; title = "HashServices"; ObjectID = "33a-jy-EES"; */
"33a-jy-EES.title" = "HashServices";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Request redirect of all Boot prefixed variables from EFI_GLOBAL_VARIABLE_GUID to OC_VENDOR_VARIABLE_GUID.\n\nThis quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi. The quirk lets default boot entry preservation at times when the firmware deletes incompatible boot entries. In summary, this quirk is required to reliably use the Startup Disk preference pane in firmware that is not compatible with macOS boot entries by design.\n\nBy redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals:\n• Operating systems are jailed and only controlled by OpenCore boot environment to enhance security.\n• Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation wakes for cases that require reboots with OpenCore in the middle.\n• Potentially incompatible boot entries, such as macOS entries, are not deleted or corrupted in any way."; ObjectID = "3Q0-sm-ooL"; */
"3Q0-sm-ooL.ibShadowedToolTip" = "啟用此項以便能夠在與 macOS 引導項設計上不相容的韌體中可靠地使用[啟動磁區]設定。\n\n提醒:一些主機板如果啟用此項，在使用resetNVRAM後會導致黑畫面無法進入BIOS的硬體損壞，必須停用此項和設定Misc-->Security-->BootProtect為None!!";

/* Class = "NSTextFieldCell"; title = "TimerResolution"; ObjectID = "3Ql-TM-Oiv"; */
"3Ql-TM-Oiv.title" = "TimerResolution";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty\nDescription: Set OEM protocol used for internal pointer driver.\nCurrently the only supported variant is ASUS, using specialised protocol available on certain Z87 and Z97 ASUS boards. The value of this property cannot be empty if PointerSupport is enabled."; ObjectID = "3mi-sh-qNa"; */
"3mi-sh-qNa.ibShadowedToolTip" = "一般留空\n它使用了某些Z87和Z97 ASUS主機板上可用的專用協議。";

/* Class = "NSButtonCell"; title = "RequestBootVarRouting"; ObjectID = "4Eq-ma-JKy"; */
"4Eq-ma-JKy.title" = "RequestBootVarRouting";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces unicode collation services with builtin versions. Set to true to ensure UEFI Shell compatibility on platforms with defective unicode collation implementations. Legacy Insyde and APTIO platforms on Ivy Bridge, and earlier, are typically affected."; ObjectID = "4bg-ao-G40"; */
"4bg-ao-G40.ibShadowedToolTip" = "一般選 NO。\n一些較舊的韌體破壞了 Unicode 排序規則, 設定為 YES 可以修復這些系統上 UEFI Shell 的相容性 (通常為用於 IvyBridge 或更舊的裝置)";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal keyboard input translation to AppleKeyMapAggregator protocol.\n\nThis option activates the internal keyboard interceptor driver, based on AppleGenericInput, also known as AptioInputFix, to fill the AppleKeyMapAggregator database for input functioning. In cases where a separate driver such as OpenUsbKbDxe is used, this option should never be enabled. Additionally, this option is not required and should not be enabled with Apple firmware."; ObjectID = "4fK-xq-9AN"; */
"4fK-xq-9AN.ibShadowedToolTip" = "開啟 OC 的內建鍵盤支援,部分筆記型電腦在開機選單界面無法使用鍵盤，請選擇它！\n如果使用 AppleUsbKbdxe.efi 請設定為 NO";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Set HDA Traffic Class Select Register to TC0.\n\nAppleHDA kext will function correctly only if TCSEL register is configured to use TC0 traffic class. Refer to Intel I/O Controller Hub 9 (ICH9) Family Datasheet (or any other ICH datasheet) for more details about this register.\n\nNote: This option is independent from AudioSupport. If AppleALC is used it is preferred to use AppleALC alctsel property instead."; ObjectID = "4mo-Ut-bYl"; */
"4mo-Ut-bYl.ibShadowedToolTip" = "將HDA流量等級選擇寄存器設定為TC0.\n\n僅當TCSEL寄存器配置為使用TC0流量等級時，AppleHDA kext才能正常執行. 有關此寄存器的更多詳細資訊，請參考 Intel I/O控制器9(ICH9)數據表(或任何其他ICH數據表).\n\n注意:此選項獨立於AudioSupport。 如果使用AppleALC，則最好改用AppleALC alctsel屬性.";

/* Class = "NSTabViewItem"; label = "Audio"; ObjectID = "5Gm-fv-IpR"; */
"5Gm-fv-IpR.label" = "開機音訊";

/* Class = "NSTextFieldCell"; title = "CustomDelays"; ObjectID = "5zT-C9-V64"; */
"5zT-C9-V64.title" = "CustomDelays";

/* Class = "NSButtonCell"; title = "JumpstartHotPlug"; ObjectID = "6B4-NA-lHR"; */
"6B4-NA-lHR.title" = "JumpstartHotPlug";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "6k6-uj-n97"; */
"6k6-uj-n97.headerCell.title" = "注釋";

/* Class = "NSTableView"; ibShadowedToolTip = "Type: plist array\nFailsafe: None\nDescription: Load selected drivers from OC/Drivers directory.\nDesigned to be filled with string filenames meant to be loaded as UEFI drivers. Depending on the firmware a different set of drivers may be required. Loading an incompatible driver may lead your system to unbootable state or even cause permanent firmware damage. Some of the known drivers include:\n• AudioDxe — HDA audio support driver in UEFI firmwares for most Intel and some other analog audio controllers.\n• CrScreenshotDxe — Screenshot making driver saving images to the root of OpenCore partition (ESP) or any avail- able writeable filesystem upon pressing F10. This is a modified version of CrScreenshotDxe driver by Nikolaj Schlej.\n• ExFatDxe — Proprietary ExFAT file system driver for Bootcamp support commonly found in Apple firmware. For Sandy Bridge and earlier CPUs, the ExFatDxeLegacy driver should be used due to the lack of RDRAND instruction support.\n• HfsPlus — Recommended. Proprietary HFS file system driver with bless support commonly found in Apple firmware. For Sandy Bridge and earlier CPUs, the HfsPlusLegacy driver should be used due to the lack of RDRAND instruction support.\n• HiiDatabase* — HII services support driver from MdeModulePkg. This driver is included in most types of firmware starting with the Ivy Bridge generation. Some applications with GUI, such as UEFI Shell, may need this driver to work properly.\n• EnhancedFatDxe — FAT filesystem driver from FatPkg. This driver is embedded in all UEFI firmware and cannot be used from OpenCore. Several types of firmware have defective FAT support implementation that may lead to corrupted filesystems on write attempts. Embedding this driver within the firmware may be required in case writing to the EFI partition is needed during the boot process.\n• NvmExpressDxe — NVMe support driver from MdeModulePkg. This driver is included in most firmware starting with the Broadwell generation. For Haswell and earlier, embedding it within the firmware may be more favourable in case a NVMe SSD drive is installed.\nOpenCanopy* — OpenCore plugin implementing graphical interface.\nOpenRuntime* — OpenCore plugin implementing OC_FIRMWARE_RUNTIME protocol.\n• OpenUsbKbDxe* — USB keyboard driver adding support for AppleKeyMapAggregator protocols on top of a custom USB keyboard driver implementation. This is an alternative to builtin KeySupport, which may work better or worse depending on the firmware.\n• OpenPartitionDxe* — Partition management driver with Apple Partitioning Scheme support. This driver can be used to support loading older DMG recoveries such as macOS 10.9 using Apple Partitioning Scheme. OpenDuet already includes this driver.\n• Ps2KeyboardDxe* — PS/2 keyboard driver from MdeModulePkg. OpenDuetPkg and some types of firmware may not include this driver, but it is necessary for PS/2 keyboard to work. Note, unlike OpenUsbKbDxe this driver has no AppleKeyMapAggregator support and thus requires KeySupport to be enabled.\n• Ps2MouseDxe* — PS/2 mouse driver from MdeModulePkg. Some very old laptop firmware may not include this driver but it is necessary for the touchpad to work in UEFI graphical interfaces such as OpenCanopy.\n• OpenHfsPlus* — HFS file system driver with bless support. This driver is an alternative to a closed source HfsPlus driver commonly found in Apple firmware. While it is feature complete, it is approximately 3 times slower and is yet to undergo a security audit.\n• UsbMouseDxe* — USB mouse driver from MdeModulePkg. Some virtual machine firmware such as OVMF may not include this driver but it is necessary for the mouse to work in UEFI graphical interfaces such as OpenCanopy.\n• XhciDxe* — XHCI USB controller support driver from MdeModulePkg. This driver is included in most types of firmware starting with the Sandy Bridge generation. For earlier firmware or legacy systems, it may be used to support external USB 3.0 PCI cards.\n\nDriver marked with * are bundled with OpenCore. To compile the drivers from UDK (EDK II) the same command used for OpenCore compilation can be taken, but choose a corresponding package:\ngit clone https://github.com/acidanthera/audk UDK cd UDK\nsource edksetup.sh\nmake -C BaseTools\nbuild -a X64 -b RELEASE -t XCODE5 -p FatPkg/FatPkg.dsc\nbuild -a X64 -b RELEASE -t XCODE5 -p MdeModulePkg/MdeModulePkg.dsc"; ObjectID = "6zo-Jl-Ryl"; */
"6zo-Jl-Ryl.ibShadowedToolTip" = "從OC/Drivers目錄載入選定的驅動程式。\n注意一下填入的順序\n根據硬體不同，可能需要不同的驅動程式。載入不相容的驅動程式可能導致系統進入無法啟動狀態，甚至導致永久性韌體損壞。一些已知的驅動程式包括:\n•ApfsDriverLoader-APFS檔案系統引導驅動程式，在UEFI韌體的可啟動APFS容器中增加了對嵌入式APFS驅動程式的支援(OC現在已經內建)。\n•FwRuntimeServices-可提高OpenCore和Lilu的安全性通過支援只讀和只讀NVRAM變量(現已更名Openruntime)。有些怪癖（例如RequestBootVarRouting）需要此驅動程式才能正常執行。由於是runtime實時驅動程式的性質，即與目标操作系統並行執行，因此無法在OpenCore本身中實現，而是與OpenCore發行版捆绑在一起。\n•EnhancedFatDxe-FatPkg中的FAT檔案系統驅動程式。此驅動程式已嵌入所有UEFI韌體中，並且無法從OpenCore使用。眾所周知，多種韌體的FAT支援實現中都有錯誤，這會導致在嘗試寫操作時損壞檔案系統。如果在引導過程中需要寫入EFI分區，則可能需要將此驅動程式嵌入韌體中。\n•NvmExpressDxe-來自MdeModulePkg的NVMe支援驅動程式。從Broadwell一代開始的大多數韌體中都包含此驅動程式。對於Haswell及更早版本，如果安裝了NVMe SSD驅動器，則將其更好地嵌入到韌體中。\n•UsbKbDxe-USB鍵盤驅動程式在自定義USB鍵盤驅動程式實現的基礎上增加了對AppleKeyMapAggregator協議的支援。這是內建KeySupport的替代方法。\n•VBoxHfs-具有支援HFS檔案系統的驅動程式。此驅動程式可以替代Apple韌體中常見的封閉源HFSPlus驅動程式。雖然功能齊全，但是大约速度慢3倍，並且尚未接受安全審核。\n•XhciDxe-MdeModulePkg中的XHCI USB控制器支援驅動程式。從Sandy Bridge代開始的大多數韌體中都包含此驅動程式。對於較早的韌體或舊系統，它可以用於支援外部USB 3.0 PCI卡\n•NdkBootPicker-標準OC第三方圖形界面模組 ";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Play chime sound at startup.\n\nEnabling this setting plays the boot chime using the builtin audio support. The volume level is determined by the MinimumVolume and VolumeAmplifier settings as well as the SystemAudioVolume NVRAM variable. Possible values include:\n• Auto — Enables chime when StartupMute NVRAM variable is not present or set to 00.\n• Enabled — Enables chime unconditionally.\n• Disabled — Disables chime unconditionally.\n\nNote: Enabled can be used in separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play the boot chime."; ObjectID = "77y-Lm-hgl"; */
"77y-Lm-hgl.ibShadowedToolTip" = "在啟動時播放提示音Duang.\n\n啟用此設定可通過內建音訊支援播放啟動鈴聲。音量級别由MinimumVolume和VolumeAmplifier設定以及SystemAudioVolume NVRAM變量確定。設定值包括:\n• Auto — 當StartupMute NVRAM變量不存在或設定為00時啟用提示音.\n• Enabled — 無條件啟用鈴聲.\n• Disabled — 無條件停用提示音.\n\n注意：Enabled可以與StartupMute NVRAM變量分開使用，以避免和BIOS播放啟動鈴聲時發生衝突.";

/* Class = "NSTextFieldCell"; title = "MinVersion"; ObjectID = "7Ns-yB-e5j"; */
"7Ns-yB-e5j.title" = "MinVersion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load embedded APFS drivers from APFS containers.\n\nAn APFS EFI driver is bundled in all bootable APFS containers. This option performs the loading of signed APFS drivers (consistent with the ScanPolicy). Refer to the “EFI Jumpstart” section of the Apple File System Reference for details."; ObjectID = "8Sc-F2-ONI"; */
"8Sc-F2-ONI.ibShadowedToolTip" = "載入嵌入式APFS驅動程式.\n此選項替代之前使用的ApfsDriverLoader.efi驅動文件，變為OC嵌入式驅動！";

/* Class = "NSTabViewItem"; label = "ReservedMemory"; ObjectID = "8vC-O7-rpe"; */
"8vC-O7-rpe.label" = "ReservedMemory";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide GOP protocol instances on top of UGA protocol instances.\n\nThis option provides the GOP protocol via a UGA-based proxy for firmware that do not implement the protocol.\n\nNote: This option requires ProvideConsoleGop to be enabled."; ObjectID = "90N-0m-rfm"; */
"90N-0m-rfm.ibShadowedToolTip" = "驅動程式載入後執行UEFI控制器連接。此選項對於載入檔案系統驅動程式很有用，該檔案系統驅動程式通常遵循UEFI驅動程式模型，並且可能無法自行啟動。雖然有效，但此選項對於執行自動連接的驅動程式可能不是必需的，並且可能會稍微减慢啟動速度。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform UEFI controller connection after driver loading.\nThis option is useful for loading drivers following UEFI driver model, as they may not start by themselves. Examples of such drivers are filesystem or audio drivers. While effective, this option may not be necessary for drivers performing automatic connection, and may slightly slowdown the boot.\n\nNote: Some types of firmware, particularly those made by Apple, only connect the boot drive to speed up the boot process. Enable this option to be able to see all the boot options when running multiple drives."; ObjectID = "9f0-xd-rhT"; */
"9f0-xd-rhT.ibShadowedToolTip" = "驅動程式載入後執行UEFI控制器連接。此選項對於載入檔案系統驅動程式很有用，該檔案系統驅動程式通常遵循UEFI驅動程式模型，並且可能無法自行啟動。雖然有效，但此選項對於執行自動連接的驅動程式可能不是必需的，並且可能會稍微减慢啟動速度。";

/* Class = "NSTextFieldCell"; title = "MinDate"; ObjectID = "9fO-yG-VWd"; */
"9fO-yG-VWd.title" = "MinDate";

/* Class = "NSButtonCell"; title = "FirmwareVolume"; ObjectID = "AW6-UR-4Ex"; */
"AW6-UR-4Ex.title" = "FirmwareVolume";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Codec address on the specified audio controller for audio support. This typically contains the first audio codec address on the builtin analog audio controller (HDEF). Audio codec addresses, e.g. 2, can be found in the debug log: \nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs) \nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative this value can be obtained from IOHDACodecDevice class in I/O Registry containing it in IOHDACodecAddress field."; ObjectID = "AZW-9D-hq6"; */
"AZW-9D-hq6.ibShadowedToolTip" = "用於音訊支援的指定音訊控制器上的編解碼器地址。通常，它包含內建模擬音訊控制器（HDEF）上的第一個音訊編解碼器地址。音訊編解碼器地址，例如2，可以在 Debug 日誌中找到：\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs) \nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\n或者，可以從I/O登錄檔軟體中的IOHDACodecDevice類取得此值，該類包含在IOHDACodecAddress字段中。";

/* Class = "NSTextFieldCell"; title = "KeyInitialDelay"; ObjectID = "Bng-Xc-8Qm"; */
"Bng-Xc-8Qm.title" = "KeyInitialDelay";

/* Class = "NSButtonCell"; title = "AppleUserInterfaceTheme"; ObjectID = "BvY-5w-QBw"; */
"BvY-5w-QBw.title" = "AppleUserInterfaceTheme";

/* Class = "NSButtonCell"; title = "Scan/Browse"; ObjectID = "CLg-lY-N26"; */
"CLg-lY-N26.title" = "掃描/瀏覽";

/* Class = "NSButtonCell"; title = "IgnoreInvalidFlexRatio"; ObjectID = "CWI-LU-4dW"; */
"CWI-LU-4dW.title" = "IgnoreInvalidFlexRatio";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activates HPET support.\n\nOlder boards like ICH6 may not always have HPET setting in the firmware preferences, this option tries to force enable it."; ObjectID = "CnN-YN-AWu"; */
"CnN-YN-AWu.ibShadowedToolTip" = "啟用HPET支援.\n\n諸如ICH6之類的舊主機板可能並不總是在韌體首選項中具有HPET設定，此選項嘗試強制啟用它.";

/* Class = "NSButtonCell"; title = "ForgeUefiSupport"; ObjectID = "D5d-rU-CDJ"; */
"D5d-rU-CDJ.title" = "ForgeUefiSupport";

/* Class = "NSButtonCell"; title = "AppleSmcIo"; ObjectID = "Ddl-D0-484"; */
"Ddl-D0-484.title" = "AppleSmcIo";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Swap Command and Option keys during submission.\nThis option may be useful for keyboard layouts with Option key situated to the right of Command key."; ObjectID = "EIc-ff-Thn"; */
"EIc-ff-Thn.ibShadowedToolTip" = "交換 Command 和 Option 鍵,一般選 NO";

/* Class = "NSTextFieldCell"; title = "KeySupportMode"; ObjectID = "EeU-wj-caf"; */
"EeU-wj-caf.title" = "KeySupportMode";

/* Class = "NSButtonCell"; title = "PointerSupport"; ObjectID = "Elq-pL-QTD"; */
"Elq-pL-QTD.title" = "PointerSupport";

/* Class = "NSTextFieldCell"; title = "VolumeAmplifier"; ObjectID = "En7-ww-Uj5"; */
"En7-ww-Uj5.title" = "VolumeAmplifier";

/* Class = "NSTextFieldCell"; title = "KeyForgetThreshold"; ObjectID = "ErN-ks-EzO"; */
"ErN-ks-EzO.title" = "KeyForgetThreshold";

/* Class = "NSTabViewItem"; label = "APFS"; ObjectID = "F1Q-I5-6w7"; */
"F1Q-I5-6w7.label" = "嵌入式APFS";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple SMC I/O protocol with a builtin version.\n\nThis protocol replaces the legacy VirtualSmc UEFI driver, and is compatible with any SMC kernel extension. \nHowever, in case FakeSMC kernel extension is used, manual NVRAM key variable addition may be needed."; ObjectID = "FPA-9t-OzA"; */
"FPA-9t-OzA.ibShadowedToolTip" = "最新版本已經內建VirtualSmc.efi協議。\n使用此選項可以删除drivers目錄下的VirtualSmc.efi文件。\n但是，如果使用FakeSMC Kernel 擴展，則可能需要手動增加NVRAM私鑰變量。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform full device connection during APFS loading.\n\nEvery handle is connected recursively instead of the partition handle connection typically used for APFS driver loading. This may result in additional time being taken but can sometimes be the only way to access APFS partitions on certain firmware, such as those on older HP laptops."; ObjectID = "H5Y-DY-WOe"; */
"H5Y-DY-WOe.ibShadowedToolTip" = "在APFS載入期間執行完整的裝置連接。\n代替通常用於APFS驅動程式載入的分區句柄連接，每個句柄都是遞規連接的。\n這可能比平時花費更多的時間，但可能是存取某些韌體（如舊版HP筆記型電腦上的韌體）上的APFS分區的唯一方法。";

/* Class = "NSButtonCell"; title = "ReplaceTabWithSpace"; ObjectID = "HIh-Oc-UT7"; */
"HIh-Oc-UT7.title" = "ReplaceTabWithSpace";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging."; ObjectID = "HdB-KO-x50"; */
"HdB-KO-x50.ibShadowedToolTip" = "隱藏APFS驅動程式載入時的詳細輸出.\nAPFS詳細輸出可用於 Debug .";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces Hash Services protocols with builtin versions. Set to true to ensure FileVault 2 compatibility on platforms with defective SHA-1 hash implementations. This can be determined by an invalid cursor size when UIScale is set to 02. Platforms earlier than APTIO V (Haswell and older) are typically affected."; ObjectID = "HpH-bP-96S"; */
"HpH-bP-96S.ibShadowedToolTip" = "一般選NO。\n修復執行FileVault時滑鼠游標大小不正確的問題, 設定為 YES 可以更好地相容FileVault";

/* Class = "NSButtonCell"; title = "DisableSecurityPolicy"; ObjectID = "IID-nc-awv"; */
"IID-nc-awv.title" = "DisableSecurityPolicy";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Image Conversion protocol with a builtin version."; ObjectID = "ILy-av-YYi"; */
"ILy-av-YYi.ibShadowedToolTip" = "重建apple圖示，一般選擇NO。";

/* Class = "NSTabViewItem"; label = "ProtocolOverrides"; ObjectID = "Ife-ug-MJ5"; */
"Ife-ug-MJ5.label" = "協議覆蓋";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Debug Log protocol with a builtin version."; ObjectID = "JLv-Tn-pJQ"; */
"JLv-Tn-pJQ.ibShadowedToolTip" = "重新安裝具有內建版本的Apple Debug Log協議。";

/* Class = "NSTextFieldCell"; title = "KeySubsequentDelay"; ObjectID = "JWy-Kv-Tq6"; */
"JWy-Kv-Tq6.title" = "KeySubsequentDelay";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Data Hub protocol with a builtin version.\n\nNote: This will discard all previous entries if the protocol was already installed, so all properties required for the safe operation of the system must be specified in the configuration file."; ObjectID = "KN0-dq-pSV"; */
"KN0-dq-pSV.ibShadowedToolTip" = "重建datahub，這裡選NO。";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• Auto — Treated as Enabled when KeySupport is true and Disabled otherwise.\n• Enabled — The values KeyInitialDelay and KeySubsequentDelay are used.\n• Disabled — Apple default values of 500ms (50) and 50ms (5) are used."; ObjectID = "Kmw-jC-ANj"; */
"Kmw-jC-ANj.ibShadowedToolTip" = "啟用自訂按鍵重複延遲.\n• 如果在KeySupport為true時將Auto視為Enabled，否則將Disabled.\n• 如果啟用，則使用值KeyInitialDelay和KeySubsequentDelay.\n• 如果已停用Apple使用500ms(50)和50ms(5)的預設值";

/* Class = "NSTextFieldCell"; title = "AudioCodec"; ObjectID = "L2f-gE-rBP"; */
"L2f-gE-rBP.title" = "AudioCodec";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver date.\n\nThe APFS driver date connects the APFS driver with the calendar release date. Apple ultimately drops support for older macOS releases and APFS drivers from such releases may contain vulnerabilities that can be used to compromise a computer if such drivers are used after support ends. This option permits restricting APFS drivers to current macOS versions.\n\n• 0 — require the default supported release date of APFS in OpenCore. The default release date will increase with time and thus this setting is recommended. Currently set to 2020/01/01.\n• -1 — permit any release date to load (strongly discouraged).\n• Other — use custom minimal APFS release date, e.g. 20200401 for 2020/04/01. APFS release dates can be found in OpenCore boot log and OcApfsLib."; ObjectID = "L9i-6i-Mis"; */
"L9i-6i-Mis.ibShadowedToolTip" = "允許的最小APFS驅動程式日期.\n較早版本的APFS驅動程式可能包含未修補的漏洞，可用來對您的電腦造成傷害. 此選項允許將APFS驅動程式限制為僅最新版本.\n• 0 — 需要OpenCore中APFS的預設支援發布日期. 預設發布日期會随著時間增加，因此建議使用此設定. 當前設定為2020/01/01.\n• -1 — 允許載入任何發布日期（強烈建議）.\n• Other — 使用自定義的最低APFS發布日期，例如2020/04/01寫成20200401. APFS發行日期可以在OpenCore引導日誌和OcApfsLib中找到.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 50 (500ms before first key repeat)\nDescription: Configures the initial delay before keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 50 (500ms).\n\nNote 1: On systems not using \\texttt{KeySupport}, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using \\texttt{KeySupport}, but which do not show the 'two long delays' behavior (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) then this setting may also be freely used to configure key repeat initial delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, you may find that you see one additional slow key repeat before normal speed key repeat starts, when holding a key down. If so, you may wish to configure KeyInitialDelay and KeySubsequentDelay according to the instructions at Note 3 of KeySubsequentDelay."; ObjectID = "LPe-Zp-8MC"; */
"LPe-Zp-8MC.ibShadowedToolTip" = "0 (無初始延遲，立刻重複)\n在Apple Event協議的OpenCore實施中配置原始鍵盤重複延遲, 以10ms為單位.\n\n不使用KeySupport時,此選項將按預期配置在按鍵重複之前的初始延遲. Apple OEM預設值是50(500ms).\n\n使用KeySupport時, 您可能會發現在正常速度鍵重複開始之前，您又得到了一個慢速鍵重複. 如果是這樣，則您的初始按鍵重複延遲是由您的BIOS韌體驅動的，並且無法被OC覆蓋. 為了避免這種輕微的不良影響, 將KeyInitialDelay設定為0. 如果這樣做, 避免對單個按鍵的多次回應, 您應該將KeySubsequentDelay至少設定為KeyForgetThreshold設定的值.";

/* Class = "NSButtonCell"; title = "OSInfo"; ObjectID = "Ljq-q2-IwF"; */
"Ljq-q2-IwF.title" = "OSInfo";

/* Class = "NSTableColumn"; headerCell.title = "Type"; ObjectID = "McE-CL-fQD"; */
"McE-CL-fQD.headerCell.title" = "類型";

/* Class = "NSTextFieldCell"; title = "SetupDelay"; ObjectID = "N4u-Hw-eXM"; */
"N4u-Hw-eXM.title" = "SetupDelay";

/* Class = "NSButtonCell"; title = "DataHub"; ObjectID = "NGa-cY-Uzn"; */
"NGa-cY-Uzn.title" = "DataHub";

/* Class = "NSTextFieldCell"; title = "Resolution"; ObjectID = "NbU-Qi-Xhw"; */
"NbU-Qi-Xhw.title" = "控制台解析度";

/* Class = "NSButtonCell"; title = "KeyFiltering"; ObjectID = "Of8-Ba-FhQ"; */
"Of8-Ba-FhQ.title" = "KeyFiltering";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 5 (50ms between subsequent key repeats)\nDescription: Configures the gap between keyboard key repeats in OpenCore implementation of Apple Event protocol, in units of 10ms.\n\nThe Apple OEM default value is 5 (50ms).\n0 is an invalid value for this option (will issue a debug log warning and use 1 instead).\n\nNote 1: On systems not using KeySupport, this setting may be freely used to configure key repeat behaviour.\n\nNote 2: On systems using KeySupport, but which do not show the 'two long delays' behaviour (see Note 3) and/or which always show a solid 'set default' indicator (see KeyForgetThreshold) (which should apply to many/most systems using AMI KeySupport mode) then this setting may be freely used to configure key repeat subsequent delay behaviour, except that it should never be set to less than KeyForgetThreshold to avoid uncontrolled key repeats.\n\nNote 3: On some systems using KeySupport, particularly KeySupport in non-AMI mode, you may find that after configuring KeyForgetThreshold you get one additional slow key repeat before normal speed key repeat starts, when holding a key down. On systems where this is the case, it is an unavoidable artefect of using KeySupport to emulate raw keyboard data, which is not made available by UEFI. While this 'two long delays' issue has minimal effect on overall usability, nevertheless you may wish to resolve it, and it is possible to do so as follows:\n• Set CustomDelays to true\n• Set KeyInitialDelay to 0\n• Set KeySubsequentDelay to at least the value of your KeyForgetThreshold setting\n\nThe above procedure works as follows:\n• Setting KeyInitialDelay to 0 cancels the Apple Event initial repeat delay (when using the OC builtin Apple Event implementation with CustomDelays enabled), therefore the only long delay you will see is the the non-configurable and non-avoidable initial long delay introduced by the BIOS key support on these machines.\n• Key-smoothing parameter KeyForgetThreshold effectively acts as the shortest time for which a key can appear to be held, therefore a key repeat delay of less than this will guarantee at least one extra repeat for every key press, however quickly the key is physically tapped.\n• In the unlikely event that you still get frequent, or occasional, double key responses after setting KeySubsequentDelay equal to your system's value of KeyForgetThreshold, then increase KeySubsequentDelay by one or two more until this effect goes away."; ObjectID = "Op9-Rz-IAN"; */
"Op9-Rz-IAN.ibShadowedToolTip" = "在Apple Event協議的OpenCore實施中配置後續鍵盤重複延遲, 以10ms為單位.\n\n配置按鍵重複之間的間隔. Apple OEM預設值為5(50毫秒). 0是此選項的無效值.\n\n使用KeySupport時, 您可能會發現在正常速度鍵重複開始之前，您又得到了一個慢速鍵重複.如果是這樣，請將KeyInitialDelay設定為0，然後將此選項至少設定為KeyForgetThreshold設定的值. (萬一仍然經常或偶爾出現, 完成此操作後，雙鍵回應, 繼續將此值設定為比KeyForgetThreshold大一或兩個 -使用有效的最低值.)";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal heard volume level from 0 to 100.\n\nThe screen reader will use this volume level when the calculated volume level is lower than MinimumVolume and the boot chime will not play if the calculated volume level is lower than MinimumVolume."; ObjectID = "PF5-bc-9Z2"; */
"PF5-bc-9Z2.ibShadowedToolTip" = "最小音量從0到100.\n\n當計算出的音量級别小於MinimumVolume時，螢幕閱讀器將使用此音量級别。如果計算出的音量小於MinimumVolume，則不會發出開機提示音。";

/* Class = "NSButtonCell"; title = "AppleAudio"; ObjectID = "POq-ge-Ugg"; */
"POq-ge-Ugg.title" = "AppleAudio";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PVa-Cc-beC"; */
"PVa-Cc-beC.title" = "Quirks";

/* Class = "NSTextFieldCell"; title = "PlayChime"; ObjectID = "PpL-lt-ruw"; */
"PpL-lt-ruw.title" = "PlayChime";

/* Class = "NSTextFieldCell"; title = "TextRenderer"; ObjectID = "QQF-qM-yZS"; */
"QQF-qM-yZS.title" = "TextRenderer(文字渲染器)";

/* Class = "NSTextFieldCell"; title = "AppleEvent"; ObjectID = "SCl-CT-PaY"; */
"SCl-CT-PaY.title" = "AppleEvent";

/* Class = "NSButtonCell"; title = "GlobalConnect"; ObjectID = "SDU-Ok-pEv"; */
"SDU-Ok-pEv.title" = "GlobalConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed multiplier in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the multiplier for pointer movements. The Apple OEM default value is 1.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedDiv, according to user preference, to achieve customised mouse movement scaling."; ObjectID = "TSX-3o-2jP"; */
"TSX-3o-2jP.ibShadowedToolTip" = "在Apple Event協議的OpenCore實現中配置指針速度倍增器. \n\n配置加倍以進行指針移動. Apple OEM預設值為1.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Attempt to detach USB controller ownership from the firmware driver. While most types of firmware manage to do this properly, or at least have an option for this, some do not. As a result, the operating system may freeze upon boot. Not recommended unless specifically required."; ObjectID = "TTJ-UT-Xng"; */
"TTJ-UT-Xng.ibShadowedToolTip" = "大部分的主機板都有自動釋放USB所有權的功能，我們選NO。如果你開機鍵盤滑鼠卡死了，或者USB失靈，試試選Yes。";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Set internal keyboard input translation to AppleKeyMapAggregator protocol mode.\n• Auto — Performs automatic choice as available with the following preference: AMI, V2, V1.\n• V1 — Uses UEFI standard legacy input protocol EFI_SIMPLE_TEXT_INPUT_PROTOCOL.\n• V2 — Uses UEFI standard modern input protocol EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.\n• AMI — Uses APTIO input protocol AMI_EFIKEYCODE_PROTOCOL.\n\nNote: Currently V1, V2, and AMI unlike Auto only do filtering of the particular specified protocol. This may change in the future versions."; ObjectID = "TTL-Rn-Avg"; */
"TTL-Rn-Avg.ibShadowedToolTip" = "Auto:鍵值轉換協議模式\nV1: UEFI 舊版輸入協議\nV2: UEFI 新輸入協議\nAMI: APTIO 輸入協議";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver version.\n\nThe APFS driver version connects the APFS driver with the macOS release. Apple ultimately drops support for older macOS releases and APFS drivers from such releases may contain vulnerabilities that can be used to compromise a computer if such drivers are used after support ends. This option permits restricting APFS drivers to current macOS versions.\n\n• 0 — require the default supported version of APFS in OpenCore. The default version will increase with time and thus this setting is recommended. Currently set to the latest point release from High Sierra.\n• -1 — permit any version to load (strongly discouraged).\n• Other — use custom minimal APFS version, e.g. 1412101001000000 from macOS Catalina 10.15.4. APFS versions can be found in OpenCore boot log and OcApfsLib."; ObjectID = "TYZ-jG-lfr"; */
"TYZ-jG-lfr.ibShadowedToolTip" = "允許的最低APFS驅動程式版本.\nAPFS驅動程式版本將APFS驅動程式與macOS版本連接. 較早的macOS版本的APFS驅動程式將不再受支援，因此可能包含未修補的漏洞，這些漏洞可用於對您的電腦造成損害. 此選項允許將APFS驅動程式限制為僅現代macOS版本.\n• 0 — 需要OpenCore中預設支援的APFS版本. 預設版本會随著時間增加，因此建議使用此設定. 當前設定為High Sierra的最新版本.\n• -1 — 允許載入任何版本(強烈建議不要這樣做).\n• Other — 使用自定義的最低APFS版本, 例如來自macOS Catalina 10.15.4的1412101001000000. 可以在OpenCore引導日誌和OcApfsLib中找到APFS版本.";

/* Class = "NSButtonCell"; title = "ReleaseUsbOwnership"; ObjectID = "UMT-DK-9B5"; */
"UMT-DK-9B5.title" = "ReleaseUsbOwnership";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Device Property protocol with a builtin version. This may be used to ensure full compatibility on VMs and legacy Macs.\n\nNote: This will discard all previous entries if the protocol was already installed, so all properties required for safe operation of the system must be specified in the configuration file."; ObjectID = "Ueb-hn-jBT"; */
"Ueb-hn-jBT.ibShadowedToolTip" = "一般選NO\n確保在 VM 或舊白蘋果上完全相容。";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Index of the output port of the specified codec starting from 0.\n\nThis typically contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes (N) in the debug log (marked in bold):\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs) \n\nThe quickest way to find the right port is to bruteforce the values from 0 to N - 1."; ObjectID = "UrW-oc-0Oc"; */
"UrW-oc-0Oc.ibShadowedToolTip" = "指定編解碼器輸出端口的索引，一般從0開始.\n\n找到正確端口的最快方法是將值從0暴力嘗試到N-1，N是在日誌裡顯示的輸出端口索引數，比如日誌裡顯示有3個輸出，可以從0-2一個一個試.";

/* Class = "NSTabViewItem"; label = "Drivers"; ObjectID = "V9Z-z9-Ejd"; */
"V9Z-z9-Ejd.label" = "UEFI驅動";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple IMG4 Verification protocol with a builtin version. This protocol is used to verify im4m manifest files used by Apple Secure Boot."; ObjectID = "XQL-ML-llQ"; */
"XQL-ML-llQ.ibShadowedToolTip" = "重新安裝具有內建版本的Apple IMG4 Verification協議。 此協議用於驗證Apple Secure Boot使用的im4m清單文件。";

/* Class = "NSButtonCell"; title = "AppleRtcRam"; ObjectID = "Xjp-N3-zFD"; */
"Xjp-N3-zFD.title" = "AppleRtcRam";

/* Class = "NSTabViewItem"; label = "AppleInput"; ObjectID = "XuU-Ep-ZXb"; */
"XuU-Ep-ZXb.label" = "AppleInput";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Disable platform security policy.\n\nNote: This setting disables various security features of the firmware, defeating the purpose of any kind of Secure Boot. Do NOT enable if using UEFI Secure Boot."; ObjectID = "Y1W-Rp-1xj"; */
"Y1W-Rp-1xj.ibShadowedToolTip" = "停用平台安全策略.\n\n注意：此設定停用韌體的各種安全功能, 以達到任何類型的安全啟動的目的.如果您使用UEFI安全啟動，請不要啟用它.";

/* Class = "NSButtonCell"; title = "UnblockFsConnect"; ObjectID = "YFj-X6-x1j"; */
"YFj-X6-x1j.title" = "UnblockFsConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty\nDescription: Device path of the specified audio controller for audio support.\n\nThis typically contains builtin analog audio controller (HDEF) device path, e.g. PciRoot(0x0)/Pci(0x1b,0x0).\nThe list of recognised audio controllers can be found in the debug log:\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative gfxutil -f HDEF command can be used in macOS. Specifying an empty device path will result in the first available audio controller being used."; ObjectID = "YTE-Ba-80O"; */
"YTE-Ba-80O.ibShadowedToolTip" = "用於音訊功能支援的指定音訊控制器的裝置路徑。\n通常，它包含內建的模擬音訊控制器（HDEF）裝置路徑, 比如:PciRoot(0x0)/Pci(0x1b,0x0).\n可以在 Debug 日誌中找到音訊控制器的列表:\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\n也可以在macOS中使用gfxutil -f HDEF命令取得或者用Hackintool工具查看音訊裝置地址。指定空的裝置路徑將導致使用第一個可用的音訊控制器.";

/* Class = "NSButtonCell"; title = "Download/Update drivers"; ObjectID = "YW9-8V-SGH"; */
"YW9-8V-SGH.title" = "下載/更新 efi驅動";

/* Class = "NSButtonCell"; title = "UnicodeCollation"; ObjectID = "ZCa-Hx-UFl"; */
"ZCa-Hx-UFl.title" = "UnicodeCollation";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Use builtin graphics output protocol renderer for console.\n\nOn certain firmware, such as on the MacPro5,1, this may provide better performance or fix rendering issues. However, this option is not recommended unless there is an obvious benefit as it may result in issues such as slower scrolling."; ObjectID = "a3V-hG-HCC"; */
"a3V-hG-HCC.ibShadowedToolTip" = "使用內建的圖形輸出協議渲染器作為控制台。\n在某些韌體上，這可能會提供更好的性能，甚至修復渲染問題，但是通常建議除非有顯著的好處，否則不要使用此選項。";

/* Class = "NSTextFieldCell"; title = "PointerSupportMode"; ObjectID = "anR-lZ-CjV"; */
"anR-lZ-CjV.title" = "PointerSupportMode";

/* Class = "NSButtonCell"; title = "ProvideConsoleGop"; ObjectID = "bdr-Pu-Crr"; */
"bdr-Pu-Crr.title" = "ProvideConsoleGop";

/* Class = "NSButtonCell"; title = "ActivateHpetSupport"; ObjectID = "c2Y-XK-b7N"; */
"c2Y-XK-b7N.title" = "ActivateHpetSupport";

/* Class = "NSButtonCell"; title = "ResetTrafficClass"; ObjectID = "cgf-ad-vIe"; */
"cgf-ad-vIe.title" = "ResetTrafficClass";

/* Class = "NSButtonCell"; title = "KeySupport"; ObjectID = "cia-MM-Epa"; */
"cia-MM-Epa.title" = "KeySupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware do not print tab characters or everything that follows them, causing difficulties in using the UEFI Shell’s builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs.\n\nNote: This option only applies to System renderer."; ObjectID = "dDZ-Zb-RKY"; */
"dDZ-Zb-RKY.ibShadowedToolTip" = "某些韌體無法列印制表符，甚至不能列印制表符之後的所有内容，從而導致困難或無法使用UEFI Shell內建的文字編輯器來編輯屬性列表和其他文件。 此選項使控制台輸出空間代替制表符。\n注意:此選項僅適用於系統渲染器才能起作用。";

/* Class = "NSButtonCell"; title = "SanitiseClearScreen"; ObjectID = "dXN-AE-igp"; */
"dXN-AE-igp.title" = "SanitiseClearScreen";

/* Class = "NSButtonCell"; title = "AppleBootPolicy"; ObjectID = "ddJ-by-qVm"; */
"ddJ-by-qVm.title" = "AppleBootPolicy";

/* Class = "NSButtonCell"; title = "AppleKeyMap"; ObjectID = "dpz-CS-4eq"; */
"dpz-CS-4eq.title" = "AppleKeyMap";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal pointer driver.\n\nThis option implements standard UEFI pointer protocol (EFI_SIMPLE_POINTER_PROTOCOL) through select OEM protocols. The option may be useful on Z87 ASUS boards, where EFI_SIMPLE_POINTER_PROTOCOL is defective."; ObjectID = "dzp-p6-AHb"; */
"dzp-p6-AHb.ibShadowedToolTip" = "如果你是華碩的Z87或者Z97，你需要打開PointerSupport這個選項。";

/* Class = "NSButtonCell"; title = "ReloadOptionRoms"; ObjectID = "eDn-1a-lDg"; */
"eDn-1a-lDg.title" = "ReloadOptionRoms";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Ensure GOP (Graphics Output Protocol) on console handle.\nmacOS bootloader requires GOP or UGA (for 10.4 EfiBoot) to be present on console handle, yet the exact location of  the graphics protocol is not covered by the UEFI specification. This option will ensure GOP and UGA, if present, are available on the console handle.\n\nNote: This option will also replace incompatible implementations of GOP on the console handle, as may be the case on the MacPro5,1 when using modern GPUs."; ObjectID = "eGd-xS-rQf"; */
"eGd-xS-rQf.ibShadowedToolTip" = "macOS 引導載入程式要求 GOP (圖形輸出協議) 存在於控制台句柄上\n大部分的筆電都不提供 GOP, 桌機的獨立顯示卡可以單獨刷入 GOP\n如果選擇了囉嗦模式啟動之後不出現Verbose詳細資訊，請啟用此項\n開啟此選項能最大可能保證 OpenCore UI 和 蘋果標誌 以正確解析度顯示";

/* Class = "NSButtonCell"; title = "HideVerbose"; ObjectID = "egr-8J-RIS"; */
"egr-8J-RIS.title" = "HideVerbose";

/* Class = "NSTextFieldCell"; title = "MinimumVolume"; ObjectID = "ehu-K3-gbY"; */
"ehu-K3-gbY.title" = "MinimumVolume";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide UGA protocol instances on top of GOP protocol instances.\n\nSome types of firmware do not implement the legacy UGA protocol but this may be required for screen output by older EFI applications such as EfiBoot from 10.4."; ObjectID = "ejz-UL-xuF"; */
"ejz-UL-xuF.ibShadowedToolTip" = "在GOP協議的基礎上提供UGA協議實例。\n\n某些韌體未實現舊版UGA協議，但較早的EFI應用程式（如10.4版以上的EfiBoot）可能需要螢幕輸出。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware reset screen resolutions to a failsafe value (such as 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to the System renderer. On all known affected systems, ConsoleMode must be set to an empty string for this option to work."; ObjectID = "f0k-6s-W9I"; */
"f0k-6s-W9I.ibShadowedToolTip" = "當使用大顯示（例如2K或4K）時，某些韌體會將螢幕解析度重置為故障安全值（如1024x768），以清除螢幕内容。此選項嘗試應用變通方法。\n注意:需要將TextRenderer設定為系統渲染模式才能使其生效。在所有已知的受影響系統上，必須將ConsoleMode設定為空字串才能使其生效。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Query PCI devices and reload their Option ROMs if available.\n\nFor example, this option allows reloading NVIDIA GOP Option ROM on older Macs after the firmware version is upgraded via ForgeUefiSupport."; ObjectID = "fDO-pY-c74"; */
"fDO-pY-c74.ibShadowedToolTip" = "查詢 PCI 設備並重新載入其 Option ROM (如果有).\n\n例如,通過 ForgeUefiSupport 升級韌體版本後,此選項允許在較舊的 Mac 上重新載入 Nvdia GOP Option ROM.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\n\nThis option allows updating the firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value typically improves performance and responsiveness of the interface and input handling.\n\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. In case of issues, this option can be left as 0."; ObjectID = "fda-QM-Vl4"; */
"fda-QM-Vl4.ibShadowedToolTip" = "韌體時鐘刷新的頻率 (單位: 100纳秒)\n華碩主機板為自己的界面使用 60000\n蘋果使用 100000";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: Auto\nDescription: Determine whether OC builtin or OEM Apple Event protocol is used.\n\nThis option determines whether Apple’s OEM Apple Event protocol is used (where available), or whether OpenCore’s reversed engineered and updated re-implementation is used. In general OpenCore’s re-implementation should be preferred, since it contains updates such as noticeably improved fine mouse cursor movement and configurable key repeat delays.\n\n• Auto — Use OEM Apple Event implementation if available, connected and recent enough to be used, otherwise use OC reimplementation. On non-Apple hardware this will use the OpenCore builtin implementation. On some Macs (e.g. classic Mac Pro) this will find the Apple implementation. On both older and newer Macs than this, this option will always or often use the OC implementation. On older Macs this is because the implementation available is too old to be used, on newer Macs it is because of optimisations added by Apple which do not connect the Apple Event protocol except when needed – e.g. except when the Apple boot picker is explicitly started. Due to its somewhat unpredicatable results, this option is not normally recommended.\n• Builtin — Always use OpenCore's updated re-implementation of the Apple Event protocol. Use of this setting is recommended even on Apple hardware, due to improvements (better fine mouse control, configurable key delays) made in the OC re-implementation of the protocol.\n• OEM — Assume Apple's protocol will be available at driver connection. On all Apple hardware where a recent enough Apple OEM version of the protocol is available -- whether or not connected automatically by Apple's firmware -- this option will reliably access the Apple implementation. On all other systems, this option will result in no keyboard or mouse support. For the reasons stated, \\texttt{Builtin} is recommended in preference to this option in most cases."; ObjectID = "frr-qu-WDh"; */
"frr-qu-WDh.ibShadowedToolTip" = "確定是否使用OC內建或OEM Apple Event協議.\n\n此選項確定是否使用Apple的OEM Apple事件協議(如果有),或者是否使用了OpenCore的反向工程和更新的重新實現. 通常，應該首選OpenCore的重新實現, 因為它包含更新，例如明顯改善了滑鼠游標的精細移動和可配置的按鍵重複延遲.\n• Auto — 自動選擇實現. 由於用於實現快速啟動時間的最佳化, 實際上，這意味著將找到並使用OpenCore重新實現，除非從Apple的啟動選擇器(如果有)中明確選擇並啟動了OpenCore(不僅僅是自動啟動).\n• Builtin — 使用OpenCore更新的Apple Event協議重新實現(推薦).\n• OEM — 假設在驅動程序連接時可以使用Apple的協議. 這樣一來，Apple的實施就可以在Apple系統上可靠地使用. 否則將不支援鍵盤或滑鼠.";

/* Class = "NSButtonCell"; title = "GopPassThrough"; ObjectID = "g7Z-iK-sN1"; */
"g7Z-iK-sN1.title" = "GopPassThrough";

/* Class = "NSButtonCell"; title = "AppleSecureBoot"; ObjectID = "gC4-eW-BlL"; */
"gC4-eW-BlL.title" = "AppleSecureBoot";

/* Class = "NSTabViewItem"; label = "Output"; ObjectID = "gJG-UT-7D3"; */
"gJG-UT-7D3.label" = "顯示輸出";

/* Class = "NSButtonCell"; title = "KeySwap"; ObjectID = "h6b-rN-daY"; */
"h6b-rN-daY.title" = "KeySwap";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty (Maintain current screen resolution)\nDescription: Sets console output screen resolution.\n• Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available.\n• Set to Max to attempt using the largest available screen resolution.\n\nOn HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for details.\n\nNote: This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true."; ObjectID = "hVw-xH-z40"; Note = "Do Not Translate"; */
"hVw-xH-z40.ibShadowedToolTip" = "設定控制台輸出螢幕解析度.\n•設定為空不更改螢幕解析度.\n•設定為Max以嘗試使用最大的可用螢幕解析度。\n注意:如果控制台句柄沒有GOP協議，這將失敗，可以將ProvideConsoleGop設定為true進行增加。";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system.\n\nThe addresses written here must be part of the memory map, have a EfiConventionalMemory type, and page-aligned (4 KBs).\n\nNote: Some types of firmware may not allocate memory areas used by S3 (sleep) and S4 (hibernation) code unless CSM is enabled causing wake failures. After comparing the memory maps with CSM disabled and enabled you could find these areas in the lower memory and fix them up by doing the reservation. Reger to the Sample.plist for details.\n\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Size\nType: plist integer\nFailsafe: 0\nDescription: Size of the reserved memory region, must be page-aligned (4 KBs).\n4. Type\nType: plist string\nFailsafe: Reserved\nDescription: Memory region type matching the UEFI specification memory descriptor types. Mapping:\n• Reserved — EfiReservedMemoryType\n• LoaderCode — EfiLoaderCode\n• LoaderData — EfiLoaderData\n• BootServiceCode — EfiBootServicesCode\n• BootServiceData — EfiBootServicesData\n• RuntimeCode — EfiRuntimeServicesCode\n• RuntimeData — EfiRuntimeServicesData\n• Available — EfiConventionalMemory\n• Persistent — EfiPersistentMemory\n• UnusableMemory — EfiUnusableMemory\n• ACPIReclaimMemory — EfiACPIReclaimMemory\n• ACPIMemoryNVS — EfiACPIMemoryNVS\n• MemoryMappedIO — EfiMemoryMappedIO\n• MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace\n• PalCode — EfiPalCode\n5. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This region will not be reserved unless set to true."; ObjectID = "hs4-gm-1Ct"; */
"hs4-gm-1Ct.ibShadowedToolTip" = "1. 地址\n保留記憶體區域的起始地址，應該將其分配為保留地址，以有效地標記操作系統無法存取的這種類型的記憶體。\n此處寫入的地址必須是記憶體映射的一部分，具有EfiConventionalMemory類型，並且是頁面對齊的(4 KBs)。\n2. 注釋\n用於為條目提供参考的任意ASCII字串。\n3. 大小\n保留記憶體區域的大小必須是頁面對齊的（4 KB）。\n4. 啟用\n除非設定為true，否則不會保留該區域。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple User Interface Theme protocol with a builtin version."; ObjectID = "iFT-xW-ZaT"; */
"iFT-xW-ZaT.ibShadowedToolTip" = "使用內建版本重新安裝Apple使用者界面主題協議。";

/* Class = "NSTextFieldCell"; title = "TscSyncTimeout"; ObjectID = "ifT-4Q-EvN"; */
"ifT-4Q-EvN.title" = "TscSyncTimeout";

/* Class = "NSButtonCell"; title = "AppleFramebufferInfo"; ObjectID = "ixW-rs-w20"; */
"ixW-rs-w20.title" = "AppleFramebufferInfo";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Audio codec reconfiguration delay in microseconds.\n\nSome codecs require a vendor-specific delay after the reconfiguration (e.g. volume setting). This option makes it configurable. A typical delay can be up to 0.5 seconds."; ObjectID = "jGE-sP-Rtr"; */
"jGE-sP-Rtr.ibShadowedToolTip" = "音訊編解碼器重新配置延遲(以微秒為單位).\n\n某些編解碼器在重新配置後需要特定於供應該商的延遲(例如，音量設定). 此選項使其可配置。通常，必要的延遲可能長達0.5秒.";

/* Class = "NSView"; ibShadowedToolTip = "Type: plist array \nDescription: Designed to be filled with plist dict values, describing memory areas exquisite to particular firmware and hardware functioning, which should not be used by the operating system. An example of such\nmemory region could be second 256 MB corrupted by Intel HD 3000 or an area with faulty RAM. See Reserved-Memory Properties section below."; ObjectID = "k2W-U9-Ysu"; */
"k2W-U9-Ysu.ibShadowedToolTip" = "設計為用plist dict值填充，描述了特定韌體和硬體功能所独有的記憶體區域，操作系統不應該使用。 例如\n記憶體區域可能是Intel HD 3000損壞的第二個256 MB記憶體或RAM故障的區域。請參考下面的“保留記憶體屬性”部分。";

/* Class = "NSTextFieldCell"; title = "Console Mode"; ObjectID = "k5b-42-EPT"; */
"k5b-42-EPT.title" = "控制台模式";

/* Class = "NSButtonCell"; title = "Connect Drivers"; ObjectID = "kBk-75-acl"; */
"kBk-75-acl.title" = "連接驅動程式";

/* Class = "NSTextFieldCell"; title = "AudioOut"; ObjectID = "kM6-tO-pns"; */
"kM6-tO-pns.title" = "AudioOut";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load APFS drivers for newly connected devices.\n\nPermits APFS USB hot plug which enables loading APFS drivers, both at OpenCore startup and during OpenCore picker dusplay. Disable if not required."; ObjectID = "kSG-eA-B2o"; */
"kSG-eA-B2o.ibShadowedToolTip" = "為新連接的裝置載入APFS驅動程式.\n不僅在OpenCore啟動時而且在啟動選擇器(開機選單)期間載入APFS驅動程式. 這允許APFS檔案系統的USB磁區熱插拔。如果不需要則停用.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the OS Info protocol with a builtin version. This protocol is typically used by the firmware and other applications to receive notifications from the macOS bootloader."; ObjectID = "l9b-pk-oii"; */
"l9b-pk-oii.ibShadowedToolTip" = "強制使用內建版本重新安裝OS Info協議。該協議通常用於從macOS引導程式，韌體或其他應用程式接收通知\n暂時沒什麼用，選擇NO.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple Framebuffer Info protocol with a builtin version. This may be used to override framebuffer information on VMs or legacy Macs to improve compatibility with legacy EfiBoot such as the one in macOS 10.4."; ObjectID = "lAy-Dr-HPx"; */
"lAy-Dr-HPx.ibShadowedToolTip" = "重新安裝具有內建版本的Apple Framebuffer Info協議。 這可用於覆蓋VM或舊版Mac上的帧緩衝區資訊，以提高與舊版EfiBoot的相容性，例如macOS 10.4中的版本。";

/* Class = "NSTableColumn"; headerCell.title = "Address"; ObjectID = "ldi-uY-9wO"; */
"ldi-uY-9wO.headerCell.title" = "地址";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty (Maintain current console mode)\nDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string.\n\nSet to Max to attempt using the largest available console mode. This option is currently ignored as the Builtin text renderer only supports one console mode.\n\nNote: This field is best left empty on most types of firmware."; ObjectID = "lye-vu-fi3"; Note = "Do Not Translate"; */
"lye-vu-fi3.ibShadowedToolTip" = "設定為空字串不更改控制台模式.設定為Max以嘗試使用最大可用控制台模式.\n大多數情況下都選擇留空！";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 1\nDescription: Configure pointer speed divisor in OpenCore implementation of Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\nConfigures the divisor for pointer movements. The Apple OEM default value is 1. 0 is an invalid value for this option.\n\nNote: The recommended value for this option is 1. This value may optionally be modified in combination with PointerSpeedMul, according to user preference, to achieve customised mouse movement scaling."; ObjectID = "maU-fq-8kE"; */
"maU-fq-8kE.ibShadowedToolTip" = "在Apple Event 協議的 OpenCore 實施中建立指針速度除數。\n\n建立除數以進行指針移動。 Apple OEM 預設值是1.0是該選項的無效值。";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: BuiltinGraphics\nDescription: Chooses renderer for text going through standard console output.\n\nCurrently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution.\n\nUEFI firmware typically supports ConsoleControl with two rendering modes: Graphics and Text. Some types of firmware do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies.\n\nValid values are combinations of text renderer and rendering mode:\n• BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl.\n• BuiltinText — Switch to Text mode and use Builtin renderer with custom ConsoleControl.\n• SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl.\n• SystemText — Switch to Text mode and use System renderer with custom ConsoleControl.\n• SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly.\n\nThe use of BuiltinGraphics is generally straightforward. For most platforms, it is necessary to enable ProvideConsoleGop and set Resolution to Max. The BuiltinText variant is an alternative BuiltinGraphics for some very old and defective laptop firmware, which can only draw in Text mode.\n\nThe use of System protocols is more complicated. Typically, the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware.\n\nNote: Some Macs, such as the MacPro5,1, may have incompatible console output when using modern GPUs, and thus only BuiltinGraphics may work for them in such cases. NVIDIA GPUs may require additional firmware upgrades."; ObjectID = "mlh-hW-OqT"; */
"mlh-hW-OqT.ibShadowedToolTip" = "為通過標準控制台輸出的文字選擇渲染器。\n目前支援兩個渲染器: Builtin 和 System. System渲染器使用主機板韌體自帶文字渲染進行文字渲染。 Builtin則繞過韌體服務，使用 OpenCore 內建文字渲染執行文字渲染。 不同的渲染器支援不同的選項集。建議使用內建渲染器，因為它支援HiDPI模式並使用全螢幕解析度。\n選項内容是文字渲染器和渲染模式的组合:\n• BuiltinGraphics — 使用 OpenCore 內建文字渲染的圖形模式, 並同時啟用 OpenCore 自帶的控制台管理, 支援 HIDPI 和全螢幕範圍顯示, 通常效果勝於下面的選項。\n• SystemGraphics — 使用主機板韌體自帶文字渲染的圖形模式, 並同時啟用 OpenCore 自帶的控制台管理。\n• SystemText — 使用主機板韌體自帶文字渲染的文字模式, 並同時啟用 OpenCore 自帶的控制台管理。\n• SystemGeneric — 使用主機板韌體自帶文字渲染的文字模式和自帶的控制台管理。\nBuiltinGraphics的使用通常很简單。對於大多數平台，必須啟用ProvideConsoleGop，將解析度選項設定為Max，並選擇配置Scale。\n系統協議的使用更加複雜。通常，首選設定是SystemGraphics或SystemText。啟用ProvideConsoleGop，將“解析度”設定為“最大”，啟用“ReplaceTabWithSpace”在幾乎所有平台上都很有用。 SanitiseClearScreen，IgnoreTextInGraphics和ClearScreenOnModeSwitch更具體，它們的使用取決於韌體。\n\n注意:某些Mac機型，比如MacPro5,1，可能在較新的GPU上的控制台輸出已損壞，因此只有BuiltinGraphics可以為它們工作。";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "n2P-We-NTM"; */
"n2P-We-NTM.headerCell.title" = "啟用";

/* Class = "NSButtonCell"; title = "DirectGopRendering"; ObjectID = "nIf-jD-bYP"; */
"nIf-jD-bYP.title" = "DirectGopRendering";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Wraps Firmware Volume protocols or installs a new version to support custom cursor images for FileVault 2. Set to true to ensure FileVault 2 compatibility on anything other than on VMs and legacy Macs.\n\nNote: Several virtual machines, including VMware, may have corrupted cursor images in HiDPI mode and thus, may also require enabling this setting."; ObjectID = "nvr-JF-3ne"; */
"nvr-JF-3ne.ibShadowedToolTip" = "一般選NO。\n修復 Filevault 的 UI 問題, 設定為 YES 可以取得更好地相容 FileVault";

/* Class = "NSButtonCell"; title = "DeviceProperties"; ObjectID = "oMi-yN-r8X"; */
"oMi-yN-r8X.title" = "DeviceProperties";

/* Class = "NSButtonCell"; title = "AudioSupport"; ObjectID = "oT1-Q2-rhc"; */
"oT1-Q2-rhc.title" = "AudioSupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware only clear part of the screen when switching from graphics to text mode, leaving a fragment of previously drawn images visible. This option fills the entire graphics screen with black colour before switching to text mode.\n\nNote: This option only applies to System renderer."; ObjectID = "qMh-AF-g0P"; */
"qMh-AF-g0P.ibShadowedToolTip" = "圖形模式切換到文字模式時，某些韌體僅清除螢幕的一部分，使先前绘制的圖像片段可見。 此選項在切換到文字模式之前用黑色填充整個圖形螢幕。\n注意:此選項僅適用於系統渲染器才能起作用。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forces Resolution to be set in cases where the desired resolution is not available by default, such as on legacy Intel GMA and first generation Intel HD Graphics (Ironlake/Arrandale). Setting Resolution to Max will try to pull the largest available resolution from the connected display’s EDID.\n\nNote: This option depends on the OC_FORCE_RESOLUTION_PROTOCOL protocol being present. This protocol is currently only supported by OpenDuetPkg. The OpenDuetPkg implementation currently only supports Intel iGPUs."; ObjectID = "qSg-5G-J1y"; */
"qSg-5G-J1y.ibShadowedToolTip" = "在預設情況下無法使用所需解析度的情況下，強制設定解析度\n如舊版Intel GMA和第一代Intel HD Graphics(Ironlake/Arrandale).將解析度設定為 Max會嘗試從連接的顯示器的EDID中取得最大的可用解析度.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Replaces the Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to certain RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array."; ObjectID = "r1b-ma-oOs"; */
"r1b-ma-oOs.ibShadowedToolTip" = "重新安裝具有內建版本的Apple RTC RAM協議。\n\n注意：Apple RTC RAM協議的內建版本可能會過滤掉選擇RTC記憶體地址的I/O嘗試。 \n地址列表可以在4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102：rtc-blacklist變量中指定為數據數组。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple boot policy protocol with a builtin version. This may be used to ensure APFS compatibility on VMs or legacy Macs.\n\nNote: This option is advisable on certain Macs, such as the MacPro5,1, that are APFS compatible but on which the Apple Boot Policy protocol has recovery detection issues."; ObjectID = "rMl-Kr-h3I"; */
"rMl-Kr-h3I.ibShadowedToolTip" = "用於確保虛擬機或舊白蘋果上相容 APFS，一般選擇NO。";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Multiplication coefficient for system volume to raw volume linear translation from 0 to 1000.\nVolume level range read from SystemAudioVolume varies depending on the codec. To transform read value in [0, 127] range into raw volume range [0, 100] the read value is scaled to VolumeAmplifier percents.\n\nNote: the transformation used in macOS is not linear, but it is very close and this nuance is thus ignored."; ObjectID = "rNr-97-fnH"; */
"rNr-97-fnH.ibShadowedToolTip" = "系統音量到原始音量線性轉換的倍數，範圍是0到1000。\n\n\n注意：macOS中使用的轉換不是線性的，但是非常接近，因此細微差别被忽略了.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable keyboard input sanity checking.\nApparently some boards such as the GA Z77P-D3 may return uninitialised data in EFI_INPUT_KEY with all input protocols. This option discards keys that are neither ASCII, nor are defined in the UEFI specification (see tables 107 and 108 in version 2.8)."; ObjectID = "rxJ-TB-rJc"; */
"rxJ-TB-rJc.ibShadowedToolTip" = "啟用鍵盤輸入的完整性檢查。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Implement partial UEFI 2.x support on EFI 1.x firmware.\n\nThis setting allows running some software written for UEFI 2.x firmware like NVIDIA GOP Option ROMs on hardware with older EFI 1.x firmware like MacPro5,1."; ObjectID = "sEw-e9-VYk"; */
"sEw-e9-VYk.ibShadowedToolTip" = "在 EFI 1.x 韌體上實現部分 UEFI 2.x 支援.\n\n此設定允許在具有較舊 EFI 1.x 韌體（例如MacPro5,1）的硬體上運行某些為 UEFI 2.x 韌體編寫的軟體（例如NVIDIA GOP Option ROM）。.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Key Map protocols with builtin versions."; ObjectID = "tY1-cE-XtN"; */
"tY1-cE-XtN.ibShadowedToolTip" = "重建蘋果功能鍵，選擇NO。";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware output text onscreen in both graphics and text mode. This is typically unexpected as random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in a different mode from Text.\n\nNote: This option only applies to the System renderer."; ObjectID = "tgx-cE-NIf"; */
"tgx-cE-NIf.ibShadowedToolTip" = "修復不用 -v 開機時在蘋果標誌上覆蓋有輸出日誌的問題。";

/* Class = "NSTabViewItem"; label = "Input"; ObjectID = "tiX-oG-c7h"; */
"tiX-oG-c7h.label" = "Apple快捷鍵相關";

/* Class = "NSButtonCell"; title = "ClearScreenOnModeSwitch"; ObjectID = "tqx-Ek-u4V"; */
"tqx-Ek-u4V.title" = "ClearScreenOnModeSwitch";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Replaces the Apple Secure Boot protocol with a builtin version."; ObjectID = "ub5-qQ-fLN"; */
"ub5-qQ-fLN.ibShadowedToolTip" = "重新安裝具有內建版本的Apple Secure Boot協議。";

/* Class = "NSTableColumn"; headerCell.title = "Size"; ObjectID = "ufL-Er-oh9"; */
"ufL-Er-oh9.headerCell.title" = "大小";

/* Class = "NSButtonCell"; title = "AppleDebugLog"; ObjectID = "uqk-49-YG8"; */
"uqk-49-YG8.title" = "AppleDebugLog";

/* Class = "NSButtonCell"; title = "UgaPassThrough"; ObjectID = "vav-dM-ieV"; */
"vav-dM-ieV.title" = "UgaPassThrough";

/* Class = "NSTextFieldCell"; title = "PointerSpeedDiv"; ObjectID = "wcl-OF-wk6"; */
"wcl-OF-wk6.title" = "PointerSpeedDiv";

/* Class = "NSTextFieldCell"; title = "ExitBootServicesDelay"; ObjectID = "wxD-TC-lrQ"; */
"wxD-TC-lrQ.title" = "ExitBootServicesDelay";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Treat duplicate key presses as held keys if they arrive during this timeout, in 10 ms units. Only applies to systems using KeySupport.\n\nAppleKeyMapAggregator protocol is supposed to contain a fixed length buffer of currently pressed keys. However, the majority of the drivers which require KeySupport report key presses as interrupts, with automatically generated key repeat behaviour with some defined initial and subsequent delay. As a result, to emulate the raw key behaviour required by several Apple boot systems, we use a timeout to merge multiple repeated keys which are submitted within a small timeout window\n\nThis option allows setting this timeout based on the platform. The recommended value for the majority of platforms is from 5 (50 milliseconds) to 7 (70 milliseconds), although values up to 9 (90 milliseconds) have been observed to be required on some PS/2 systems.For reference, holding a key on VMware will repeat roughly every 20 milliseconds and the equivalent value for APTIO V is 30-40 milliseconds. KeyForgetThreshold should be configured to be longer than this. Thus, it is possible to configure a lower KeyForgetThreshold value on platforms with a faster native driver key repeat rate, for more responsive input, and it is required to set a higher value on slower platforms.\n\nPressing keys one after the other results in delays of at least 60 and 100 milliseconds for the same platforms. Ideally, KeyForgetThreshold should remain lower than this value, to avoid merging real key presses.\n\nTuning the value of KeyForgetThreshold is necessary for accurate and responsive keyboard input on systems on which KeySupport is enabled, and it is recommended to follow the instructions below to tune it correctly for your system.\n\nNote 1: To tune KeyForgetThreshold, you may use the 'set default' indicator within either OpenCanopy or the builtin picker. If KeyForgetThreshold is too low then the 'set default' indicator will continue to flicker while CTRL or =/+ is held down. You should configure the lowest value which avoids this flicker. On some systems (e.g. Aptio IV and potentially other systems using AMI KeySupport mode) you will be able to find a minimum KeyForgetThreshold value at which the 'set default' indicator goes on and stays on with no flicker at all - if so, use this value. On most other systems using KeySupport, you will find that the 'set default' indicator will flicker once, when first pressing and holding the CTRL or =/+ key, and then after a further very brief interval will go on and stay on. On such systems, you should chose the lowest value of KeyForgetThreshold at which you see only one initial flicker and then no subsequent flickering. (Where this happens, it is an unavoidable artefect on those systems of using KeySupport to emulate raw keyboard data, which is not made available by UEFI.)\n\nNote 2: KeyForgetThreshold should never need to be more than about 9 or 10 at most. If it is set to a value much higher than this, it will result in noticeably unresponsive keyboard input. Therefore, for overall key responsiveness, it is strongly recommended to configure a relatively lower value, at which the 'set default' indicator flickers once and then does not flicker, rather than using a much higher value (i.e. significantly greater than 10), which you may be able to find but should not use, where the 'set default' indicator does not flicker at all."; ObjectID = "xNH-9V-3kd"; */
"xNH-9V-3kd.ibShadowedToolTip" = "按住按鍵後每個鍵之間的時間間隔 (單位: 毫秒)\n此選項允許根據您的平台設定此逾時。 在大多數平台上均可使用的建議值為5毫秒。 作為参考，在VMware上按住一個鍵大约每2毫秒重複一次，而APTIO V的相同值是3-4毫秒。 因此，可以在較快的平台上設定稍低的值，而在較慢的平台上設定稍高的值，以提高回應速度。";

/* Class = "NSButtonCell"; title = "CustomDelays"; ObjectID = "xPB-Sk-c8h"; */
"xPB-Sk-c8h.title" = "CustomDelays";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable custom key repeat delays when using the OpenCore implementation of the Apple Event protocol. Has no effect when using the OEM Apple implementation (see AppleEvent setting).\n\n• true — The values of KeyInitialDelay and KeySubsequentDelay are used.\n• false — Apple default values of 500ms (50) and 50ms (5) are used."; ObjectID = "xpZ-sA-YNw"; */
"xpZ-sA-YNw.ibShadowedToolTip" = "使用 Apple Event 協議的 OpenCore 實施時啟用自訂按鍵重複延遲. 使用 OEM Apple實施時無效 (請參閱 AppleEvent 設定).\n\n• true — 使用 KeyInitialDelay 和 KeySubsequentDelay 的值.\n• false — 蘋果使用(50)500ms和(5)50ms的預設值.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Adds delay in microseconds after EXIT_BOOT_SERVICES event.\n\nThis is a very rough workaround to circumvent the Still waiting for root device message on some APTIO IV firmware (ASUS Z87-Pro) particularly when using FileVault 2. It appears that for some reason, they execute code in parallel to EXIT_BOOT_SERVICES, which results in the SATA controller being inaccessible from macOS. A better approach is required and Acidanthera is open to suggestions. Expect 3 to 5 seconds to be adequate when this quirk is needed."; ObjectID = "yXm-Kd-A6O"; */
"yXm-Kd-A6O.ibShadowedToolTip" = "可以繞過選定的APTIO IV韌體，即ASUS Z87-Pro上出現的\"Still waiting for root device\" 的提示資訊，特别是在使用FileVault 2時。由於某種原因，導致無法從macOS存取SATA控制器。應該在將來找到更好的方法。如果使用此，則需要設定3-5秒才可以。\n一般保持預設值 0，不要随便更改！";

/* Class = "NSButtonCell"; title = "IgnoreTextInGraphics"; ObjectID = "ygR-oy-xAC"; */
"ygR-oy-xAC.title" = "IgnoreTextInGraphics";

/* Class = "NSButtonCell"; title = "AppleImg4Verification"; ObjectID = "ytA-jO-wqX"; */
"ytA-jO-wqX.title" = "AppleImg4Verification";

/* Class = "NSButtonCell"; title = "ReconnectOnResChange"; ObjectID = "zen-LP-Fan"; */
"zen-LP-Fan.title" = "ReconnectOnResChange";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware block partition handles by opening them in By Driver mode, resulting in an inability to install File System protocols.\n\nNote: This quirk is useful in cases where unsuccessful drive detection results in an absence of boot entries."; ObjectID = "zhZ-UN-ASB"; */
"zhZ-UN-ASB.ibShadowedToolTip" = "HP筆電在 OpenCore 引導界面沒有引導項時設定為 YES";
